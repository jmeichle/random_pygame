#!/usr/bin/python
import pygame, time, sys, random, math
from pprint import pprint
from Queue import Queue
from threading import Thread

WORKER_THREAD_SLEEP_TIME = 0.5
DISPLAY_LOOP_SLEEP_TIME = 0.01

# The total size of the window to draw. The window will be a square of (size x size)
size = 800
# The number of squares to draw in on the screen. 
# This value is used for number of rows and columns, and the screen will have
# (gridsize x gridsize) cells
gridsize = int(sys.argv[2])
# Either 'random' or 'pattern'
#
# 'pattern' mode takes the defined list of colors and generates boards from them
# adding each element in per iteration of the board worker thread. When all colors
# in the pattern are used, the board resets to just black, and builds again. 
# 
# 'random' mode does the same, however each color is a random color. This iterates until the
# randomized pattern is the same size as the gridsize, and then resets. 
operating_mode = sys.argv[1]

q = Queue()
# Jenky calculation of the size of each cell as a square on the screen.
# This does not scale well with high numbers, or with numbers that mismatch the ratio of the total size.
chunks = size/gridsize

# Initial colors hash, mapping strings to RGB tuples. 
colors = {
  'red': (255,0,0),
  'green': (0,255,0),
  'blue': (0,0,255),
  'white': (255,255,255),
  'black': (0,0,0)
}

def board_worker():
    # The pattern for operating_mode == 'pattern'
    new_colors = ['white', 'red', 'green', 'blue']
    # Base color to always start with
    pattern = ['black']
    idx = 0
    # suffix for random color generation.
    random_number = 0
    while True:
      if operating_mode == 'random':
        # Generate a unique random color string. Upon render, this string will be
        # converted into an RGB tuple and saved to the colors hash for later re-use. 
        pattern.append("random-%d" % (random_number))
        random_number = random_number + 1
        reset_index = gridsize
      elif operating_mode == 'pattern':
        pattern.append(new_colors[idx])
        reset_index = len(new_colors)
      # generate and add the new board to the queue for display. 
      q.put(generate_board_from_pattern(pattern))
      # cleanup and sleep.
      idx = idx + 1
      if idx == reset_index:
        idx = 0
        pattern = ['black']
      time.sleep(WORKER_THREAD_SLEEP_TIME)

# boards are two dimensional arrays of color "strings", such as 'red', or 'black'.
# The board is generated by working left to right, top to bottom for board size (gridsize x gridsize)
# and filling in the values of the board from the pattern values. 
# values are repeated when the board has more cells than the pattern has indicies.
def generate_board_from_pattern(pattern):
  cnt = 0
  board = []
  for x in range(gridsize):
    tmplist = []
    for y in range(gridsize):
      tmplist.append(pattern[cnt])
      if cnt == (len(pattern)-1):
        cnt = 0
      else:
        cnt = cnt + 1
    board.append(tmplist)
  return board

# This renders a board array to the screen using pygame.draw, and some crude 
# maths to determine location within the grid. boards contain strings for the colors,
# and if a color string does not exist in the colors hash, one is generated randomly and
# saved to the colors hash.
def render_board_to_screen(board, screen):
  for x in range(gridsize):
    ypos = x*chunks
    for y in range(gridsize):
      xpos = y*chunks
      color_string = board[x][y]
      if not color_string in colors:
        colors[color_string] = (random.randint(0,255), random.randint(0,255), random.randint(0,255))
      color = colors[board[x][y]]
      pygame.draw.rect(screen, color, (xpos, ypos, chunks, chunks), 0)

# Start the board generator thread. This generates boards and adds them into Queue q
t = Thread(target=board_worker)
t.daemon = True
t.start()

# create the pygame screen of the given size.
screen = pygame.display.set_mode((size, size))

# loop over reads from the queue, and when a board is received draw it. 
running = True
while running:
  for event in pygame.event.get():
    if event.type == pygame.QUIT:
      running = False
  try: 
    board = q.get()
    render_board_to_screen(board, screen)
    pygame.display.flip()
    count += 1
  except: pass
  time.sleep(DISPLAY_LOOP_SLEEP_TIME)